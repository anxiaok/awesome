import{_ as n,c as a,b as e,o as t}from"./app-DvL9NwtO.js";const p="/awesome/enqueueSetState.png",o={};function c(l,s){return t(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="react-进阶实践" tabindex="-1"><a class="header-anchor" href="#react-进阶实践"><span>React 进阶实践</span></a></h1><p>参考文档：<a href="https://www.yuque.com/ergz/web/gzitt4" target="_blank" rel="noopener noreferrer">二公子</a></p><h2 id="认识jsx" tabindex="-1"><a class="header-anchor" href="#认识jsx"><span>认识jsx</span></a></h2><p><code>jsx</code>语法实现来源于<code>babel</code>插件</p><blockquote><p>@babel/plugin-syntax-jsx : 有效的解析<code>JSX</code>语法<br> @babel/plugin-transform-react-jsx：将<code>JSX</code>语法转换为js能够识别的 <code>createElement</code> 格式</p></blockquote><p>新版本React不再需要引入<code>createElement</code>,这种模式来源于<code>Automatic Runtime</code>。</p><p><code>fiber</code>是React16引入的一种新的架构，它的核心思想是将组件的渲染过程拆分成多个小的任务，每个任务称为一个<code>fiber</code>。</p><p>在 React 15 及更早版本，更新机制是同步递归 Diff：</p><blockquote><ol><li>触发更新（<code>setState</code>、<code>props</code> 变化）；</li><li>React 立刻开始对比新旧 <code>Virtual DOM</code>，递归遍历整个组件树；</li><li>这个过程一旦开始，就不能停，必须从头到尾执行完；</li><li>执行期间会完全霸占浏览器主线程，<code>JS</code> 引擎没空做渲染、响应用户点击、输入、滚动。</li></ol></blockquote><p>如果组件树很大、逻辑复杂，Diff 耗时超过 16ms（浏览器一帧大概 16.67ms），就会出现：</p><blockquote><ol><li>输入框打字卡顿</li><li>按钮点击没反应</li><li>滚动掉帧、页面卡死</li><li>动画不流畅</li></ol></blockquote><p>这就是所谓的 “卡顿瓶颈”，旧架构天生无法解决。</p><p><strong>简单说：</strong></p><blockquote><p>旧版：递归虚拟 DOM 树 → 不可中断；<br> Fiber 版：链表结构的 Fiber 树 → 循环遍历，随时可以暂停。</p></blockquote><p><strong>优势：</strong></p><blockquote><ol><li>时间切片</li><li>优先级调度</li><li>可中断、可恢复、可复用</li><li>为新特性打下基础</li></ol></blockquote><h2 id="component" tabindex="-1"><a class="header-anchor" href="#component"><span>Component</span></a></h2><p>组件分为两类：类(Class)组件和函数(Function)组件</p><p><strong>Class类组件：</strong></p><blockquote><ol><li>继承了<code>React.Component</code>类</li><li>底层还加入了<code>updater</code>对象</li><li>调用<code>setState</code> 和 <code>forceUpdate</code> 方法时，本质是调用了<code>updater</code>对象上的<code>enqueueSetState</code>和<code>enqueueForceUpdate</code>方法。</li></ol></blockquote><p><strong>Function函数组件：</strong></p><blockquote><p>可以做类组件一起能做的事情</p></blockquote><p><strong>本质区别：</strong></p><blockquote><p>类组件：底层只需要实例化一次，实例中保存了组件的state等状态,只需要调用render或者对应的生命周期就可以了 函数组件：每次更新都是一次新的调用，里面的变量会重新声明</p></blockquote><p><strong>通信方式：</strong></p><ol><li>props 和 callback方式</li><li>ref方式</li><li>React-redux 或React-mobx状态管理方式</li><li>context 上下文方式</li><li>event bus事件总线</li></ol><h2 id="state" tabindex="-1"><a class="header-anchor" href="#state"><span>state</span></a></h2><blockquote><p>state到底是同步还是异步的？ 答：回答出battchUpdate的概念，以及批量更新被打破的条件,将来被颠覆</p></blockquote><p>React有多种模式：</p><blockquote><ol><li>legacy模式</li><li>concurrent模式 (未来的稳定默认版本)</li></ol></blockquote><ol><li>类组件中的state</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">setState</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>callback<span class="token punctuation">)</span></span>
<span class="line"><span class="token literal-property property">obj</span><span class="token operator">:</span> </span>
<span class="line">    <span class="token operator">-</span> 对象，则为即将合并的state</span>
<span class="line">    <span class="token operator">-</span> 函数，参数：state和props 作为参数， 返回值用于合并新的state</span>
<span class="line"></span>
<span class="line"><span class="token literal-property property">callback</span><span class="token operator">:</span> 可选参数，状态更新完成后的回调函数</span>
<span class="line"></span>
<span class="line"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> props<span class="token punctuation">.</span>step</span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类组件如何限制state更新视图？</p><blockquote><ol><li>pureComponent 可以对state和props进行浅比较，如果没有发生变化，那么组件不更新</li><li>shouldComponentUpdate 生命周期可以判断前后state变化来决定组件需不需要更新，需要返回true,否则不更新</li></ol></blockquote><p><strong>setState原理揭秘</strong></p><ol><li>enqueueSetState到底做了什么？ <img src="`+p+`" alt="enqueueSetState"></li></ol><p>创建一个update,放入当前fiber对象的待更新队列中，最后开启调度更新，进行批量更新。 batchdEventUpdates方法： setTimeout里面的就会被打破 批量更新方法：unstable_batchedUpdates</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">ReactDOM<span class="token punctuation">.</span><span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>flusync中的setState &gt; 正常执行上下文中的setState &gt; setTimeout中的setState &gt; 微任务中(promise)的setState</p><p><strong>useState的用法</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initData<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token literal-property property">state</span><span class="token operator">:</span> 渲染视图的数据源</span>
<span class="line"><span class="token literal-property property">dispatch</span><span class="token operator">:</span> </span>
<span class="line">    <span class="token operator">-</span> 非函数<span class="token punctuation">,</span> 作为新的值，赋值给state<span class="token punctuation">,</span>作为下一次渲染使用</span>
<span class="line">    <span class="token operator">-</span> 函数，参数（dreducer<span class="token punctuation">,</span>reducer）返回值作为新的state</span>
<span class="line"><span class="token literal-property property">initData</span><span class="token operator">:</span> </span>
<span class="line">    <span class="token operator">-</span> 初始值</span>
<span class="line">    <span class="token operator">-</span> 函数，返回初始值</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,41)])])}const r=n(o,[["render",c]]),u=JSON.parse('{"path":"/react.html","title":"React 进阶实践","lang":"zh-CN","frontmatter":{},"git":{"contributors":[{"name":"安晓凯","username":"","email":"xiaokai.an@17zuoye.com","commits":1}],"changelog":[{"hash":"9d63165ab1d659f6f6902440afd29500cb7f8ae7","time":1769689566000,"email":"xiaokai.an@17zuoye.com","author":"安晓凯","message":"feat:增加React"}]},"filePathRelative":"react.md"}');export{r as comp,u as data};
