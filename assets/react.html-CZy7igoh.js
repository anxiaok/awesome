import{_ as s,c as a,b as e,o as p}from"./app-DWlosiBp.js";const t="/awesome/enqueueSetState.png",l={};function o(c,n){return p(),a("div",null,[...n[0]||(n[0]=[e(`<h1 id="react-进阶实践" tabindex="-1"><a class="header-anchor" href="#react-进阶实践"><span>React 进阶实践</span></a></h1><p>参考文档：<a href="https://www.yuque.com/ergz/web/gzitt4" target="_blank" rel="noopener noreferrer">二公子</a></p><h2 id="认识jsx" tabindex="-1"><a class="header-anchor" href="#认识jsx"><span>认识jsx</span></a></h2><p><code>jsx</code>语法实现来源于<code>babel</code>插件</p><blockquote><p>@babel/plugin-syntax-jsx : 有效的解析<code>JSX</code>语法<br> @babel/plugin-transform-react-jsx：将<code>JSX</code>语法转换为js能够识别的 <code>createElement</code> 格式</p></blockquote><p>新版本React不再需要引入<code>createElement</code>,这种模式来源于<code>Automatic Runtime</code>。</p><p><code>fiber</code>是React16引入的一种新的架构，它的核心思想是将组件的渲染过程拆分成多个小的任务，每个任务称为一个<code>fiber</code>。</p><p>在 React 15 及更早版本，更新机制是同步递归 Diff：</p><blockquote><ol><li>触发更新（<code>setState</code>、<code>props</code> 变化）；</li><li>React 立刻开始对比新旧 <code>Virtual DOM</code>，递归遍历整个组件树；</li><li>这个过程一旦开始，就不能停，必须从头到尾执行完；</li><li>执行期间会完全霸占浏览器主线程，<code>JS</code> 引擎没空做渲染、响应用户点击、输入、滚动。</li></ol></blockquote><p>如果组件树很大、逻辑复杂，Diff 耗时超过 16ms（浏览器一帧大概 16.67ms），就会出现：</p><blockquote><ol><li>输入框打字卡顿</li><li>按钮点击没反应</li><li>滚动掉帧、页面卡死</li><li>动画不流畅</li></ol></blockquote><p>这就是所谓的 “卡顿瓶颈”，旧架构天生无法解决。</p><p><strong>简单说：</strong></p><blockquote><p>旧版：递归虚拟 DOM 树 → 不可中断；<br> Fiber 版：链表结构的 Fiber 树 → 循环遍历，随时可以暂停。</p></blockquote><p><strong>优势：</strong></p><blockquote><ol><li>时间切片</li><li>优先级调度</li><li>可中断、可恢复、可复用</li><li>为新特性打下基础</li></ol></blockquote><h2 id="component" tabindex="-1"><a class="header-anchor" href="#component"><span>Component</span></a></h2><p>组件分为两类：类(Class)组件和函数(Function)组件</p><p><strong>Class类组件：</strong></p><blockquote><ol><li>继承了<code>React.Component</code>类</li><li>底层还加入了<code>updater</code>对象</li><li>调用<code>setState</code> 和 <code>forceUpdate</code> 方法时，本质是调用了<code>updater</code>对象上的<code>enqueueSetState</code>和<code>enqueueForceUpdate</code>方法。</li></ol></blockquote><p><strong>Function函数组件：</strong></p><blockquote><p>可以做类组件一起能做的事情</p></blockquote><p><strong>本质区别：</strong></p><blockquote><p>类组件：底层只需要实例化一次，实例中保存了组件的state等状态,只需要调用render或者对应的生命周期就可以了 函数组件：每次更新都是一次新的调用，里面的变量会重新声明</p></blockquote><p><strong>通信方式：</strong></p><ol><li>props 和 callback方式</li><li>ref方式</li><li>React-redux 或React-mobx状态管理方式</li><li>context 上下文方式</li><li>event bus事件总线</li></ol><h2 id="state" tabindex="-1"><a class="header-anchor" href="#state"><span>state</span></a></h2><blockquote><p>state到底是同步还是异步的？ 答：回答出battchUpdate的概念，以及批量更新被打破的条件,将来被颠覆</p></blockquote><p>React有多种模式：</p><blockquote><ol><li>legacy模式</li><li>concurrent模式 (未来的稳定默认版本)</li></ol></blockquote><ol><li>类组件中的state</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">setState</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>callback<span class="token punctuation">)</span></span>
<span class="line"><span class="token literal-property property">obj</span><span class="token operator">:</span> </span>
<span class="line">    <span class="token operator">-</span> 对象，则为即将合并的state</span>
<span class="line">    <span class="token operator">-</span> 函数，参数：state和props 作为参数， 返回值用于合并新的state</span>
<span class="line"></span>
<span class="line"><span class="token literal-property property">callback</span><span class="token operator">:</span> 可选参数，状态更新完成后的回调函数</span>
<span class="line"></span>
<span class="line"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> props<span class="token punctuation">.</span>step</span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类组件如何限制state更新视图？</p><blockquote><ol><li>pureComponent 可以对state和props进行浅比较，如果没有发生变化，那么组件不更新</li><li>shouldComponentUpdate 生命周期可以判断前后state变化来决定组件需不需要更新，需要返回true,否则不更新</li></ol></blockquote><p><strong>setState原理揭秘</strong></p><ol><li>enqueueSetState到底做了什么？ <img src="`+t+`" alt="enqueueSetState"></li></ol><p>创建一个update,放入当前fiber对象的待更新队列中，最后开启调度更新，进行批量更新。 batchdEventUpdates方法： setTimeout里面的就会被打破 批量更新方法：unstable_batchedUpdates</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">ReactDOM<span class="token punctuation">.</span><span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>flusync中的setState &gt; 正常执行上下文中的setState &gt; setTimeout中的setState &gt; 微任务中(promise)的setState</p><p><strong>useState的用法</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initData<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token literal-property property">state</span><span class="token operator">:</span> 渲染视图的数据源</span>
<span class="line"><span class="token literal-property property">dispatch</span><span class="token operator">:</span> </span>
<span class="line">    <span class="token operator">-</span> 非函数<span class="token punctuation">,</span> 作为新的值，赋值给state<span class="token punctuation">,</span>作为下一次渲染使用</span>
<span class="line">    <span class="token operator">-</span> 函数，参数（dreducer<span class="token punctuation">,</span>reducer）返回值作为新的state</span>
<span class="line"><span class="token literal-property property">initData</span><span class="token operator">:</span> </span>
<span class="line">    <span class="token operator">-</span> 初始值</span>
<span class="line">    <span class="token operator">-</span> 函数，返回初始值</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="props" tabindex="-1"><a class="header-anchor" href="#props"><span>props</span></a></h2><h3 id="props-可以是什么" tabindex="-1"><a class="header-anchor" href="#props-可以是什么"><span>props 可以是什么？</span></a></h3><ol><li>子组件渲染数据源</li><li>通知父组件的回调函数</li><li>单纯的组件传递</li><li>渲染函数</li><li>render props, 和4的区别是放在了children属性上</li><li>render component 插槽组件</li></ol><h3 id="如何定义props" tabindex="-1"><a class="header-anchor" href="#如何定义props"><span>如何定义props?</span></a></h3><ol><li>组件层级：可以把数据层传递给子组件去渲染消费，也可以通过callback向父组件传递信息</li><li>更新机制中：diff是他的驱动器，变化即更新，于是有了pureComponent,memo等性能优化方案</li><li>插槽：组件的闭合标签里的插槽，转化为Children属性</li></ol><h3 id="监听props改变" tabindex="-1"><a class="header-anchor" href="#监听props改变"><span>监听props改变</span></a></h3><p>类组件中：</p><ol><li>componentWillReceiveProps 生命周期方法，在props改变时调用,但是已经不推荐使用</li><li>getDerivedStateFromProps 静态方法，在props改变时调用，返回值用于更新state</li></ol><p>函数组件中：</p><ol><li>使用useEffect钩子函数，监听props变化， 初始化会默认执行一次</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 处理props变化的逻辑</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>someProp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="props-children模式" tabindex="-1"><a class="header-anchor" href="#props-children模式"><span>props+children模式</span></a></h3><ol><li>props插槽组件</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token operator">&lt;</span>container<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token operator">&lt;</span>Children <span class="token operator">/</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token operator">&lt;</span><span class="token operator">/</span>container<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>操作props小技巧</li></ol><p>抽象props: 不需要指定props的名称，将props直接传入或者抽离到子组件中<br> 抽离props: const { children, ...rest } = props;<br> 注入props<br> 显示注入props<br> 隐式注入props</p><h2 id="lifecycle" tabindex="-1"><a class="header-anchor" href="#lifecycle"><span>lifeCycle</span></a></h2><p>React的两个重要阶段：<br> render阶段：深度遍历fiber树，发现diff,对于变化的组件，就会执行render函数<br> commit阶段：将render阶段的结果，渲染到真实DOM上</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">undateClassComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> sholdUpdate<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">const</span> instance <span class="token operator">=</span> worInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">constructClassInstance</span><span class="token punctuation">(</span>worInProgress<span class="token punctuation">,</span> Component<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">mountClassInstance</span><span class="token punctuation">(</span>worInProgress<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> nextProps<span class="token punctuation">,</span> renderExpirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        shouldUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        shouldUpdate <span class="token operator">=</span> <span class="token function">updateClassInstance</span><span class="token punctuation">(</span>worInProgress<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> nextProps<span class="token punctuation">,</span> nextState<span class="token punctuation">,</span> renderExpirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        nextCurrent <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">reconcileChildren</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> nextCurrent<span class="token punctuation">,</span> renderExpirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line">instace 类组件对应实例</span>
<span class="line">workInProgress树：正在调和的fiber树</span>
<span class="line">current树：初始化更新中，current<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> 在第一次fiber调和之后，会将workInProgress赋值给current</span>
<span class="line">Component 就是项目中的<span class="token keyword">class</span>组件</span>
<span class="line">nextProps 作为组件在一次更新中新的props</span>
<span class="line">renderExpirationTime 渲染过期时间</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>mountClassInstance和updateClassInstance：</p><ol><li><p>mountClassInstance：组件挂载时调用，初始化组件的state和props</p></li><li><p>updateClassInstance：组件更新时调用，根据新的props和state，更新组件的视图</p></li><li><p>初始化阶段：</p><ul><li>调用构造函数 constructor</li><li>getDerivedStateFromProps 静态方法，初始化state / 调用 componentWillMount 生命周期方法</li><li>调用 render 方法</li><li>调用 componentDidMount 生命周期方法</li></ul></li><li><p>更新阶段：</p><ul><li>调用 componentWillReceiveProps 生命周期方法</li><li>getDerivedStateFromProps 静态方法，更新state</li><li>调用 shouldComponentUpdate 生命周期方法，判断是否需要更新</li><li>调用 componentWillUpdate 生命周期方法</li><li>调用 render 方法</li><li>getSnapshotBeforeUpdate 静态方法，获取更新前的快照</li><li>调用 componentDidUpdate 生命周期方法</li></ul></li><li><p>销毁阶段：</p><ul><li>调用 componentWillUnmount 生命周期方法</li></ul></li></ol><h2 id="各阶段生命周期能做些什么" tabindex="-1"><a class="header-anchor" href="#各阶段生命周期能做些什么"><span>各阶段生命周期能做些什么？</span></a></h2><ol><li>constructor: <ul><li>初始化state和props</li><li>绑定事件处理函数</li><li>必要生命周期的劫持，渲染劫持，更适合反向继承的HOC</li></ul></li><li>getDerivedStateFromProps（nextProps, prevState）: <ul><li>根据props更新state</li><li>代替componentWillMount和componentWillReceiveProps</li><li>返回值和state合并完，可以作为shouldComponentUpdate的第二个参数newState, 用于判断是否需要更新组件</li></ul></li><li>componentWillMount: <ul><li>组件挂载前调用</li><li>UNSAFE_componentWillMount: 不推荐使用，未来会被移除</li></ul></li><li>render: <ul><li>渲染组件的视图</li><li>createElement创建元素，cloneElement克隆元素,React.children遍历children的操作</li></ul></li><li>componentDidMount: <ul><li>组件挂载后调用</li></ul></li><li>componentWillReceiveProps: <ul><li>在props改变时调用</li><li>UNSAFE_componentWillReceiveProps: 不推荐使用，未来会被移除</li><li>在props不变的前提下，PureComponent组件能否阻止componentWillReceiveProps的调用？</li><li>答案：不能，因为PureComponent只对props和state进行浅比较，而componentWillReceiveProps是在props改变时调用的</li></ul></li><li>shouldComponentUpdate: <ul><li>判断是否需要更新组件</li></ul></li><li>componentWillUpdate: <ul><li>在组件更新前调用</li><li>UNSAFE_componentWillUpdate: 不推荐使用，未来会被移除</li></ul></li><li>getSnapshotBeforeUpdate: <ul><li>在组件更新前调用，返回值作为componentDidUpdate的第三个参数</li></ul></li><li>componentDidUpdate: <ul><li>在组件更新后调用</li></ul></li><li>componentWillUnmount: <ul><li>在组件卸载前调用</li></ul></li></ol><h2 id="react-hooks" tabindex="-1"><a class="header-anchor" href="#react-hooks"><span>react hooks</span></a></h2><ol><li>useEffect 和 useLayoutEffect 区别 <ul><li>useEffect：在组件挂载后和更新后异步执行，不会阻塞浏览器渲染，浏览器绘制之后执行</li><li>useLayoutEffect：在组件挂载后和更新后同步执行，会阻塞浏览器渲染, DOM更新之后，浏览器绘制之前，浏览器只绘制一次， 修改DOM，改变布局就用useLayoutEffect, 其他情况用useEffect</li></ul></li></ol><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 处理副作用的逻辑</span></span>
<span class="line">    <span class="token keyword">return</span> destory<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>dependency<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">第一个参数callback<span class="token punctuation">,</span> 副作用的处理函数</span>
<span class="line">第二个参数dependency<span class="token punctuation">,</span> 依赖数组，当依赖数组中的值发生变化时，才会执行副作用的处理函数</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问：React.useEffect 和componentDidMount/ componentDidUpdate 执行时机有什么区别？</p><p>答： useEffect： 组件挂载后和更新后异步执行，不会阻塞浏览器渲染，浏览器绘制之后执行 componentDidMount/ componentDidUpdate： 他们两个是同步执行的，时机上和useLayoutEffect更类似</p><p>useInsertionEffect：执行时机比useLayoutEffect更早，在DOM更新之前执行,主要解决css-in-js在渲染中注入样式的性能问题。</p><h2 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>Ref</span></a></h2><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token number">1.</span> 类组件React<span class="token punctuation">.</span>createRef</span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>currentDom <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token operator">-</span> Ref属性是一个字符串</span>
<span class="line">        <span class="token operator">-</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token string">&quot;currentDom&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token operator">-</span> Ref属性是一个函数</span>
<span class="line">        <span class="token operator">-</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">dom</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>currentDom <span class="token operator">=</span> dom<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token operator">-</span> Ref属性是一个ref对象</span>
<span class="line">        <span class="token operator">-</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentDom<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line"><span class="token number">2.</span> 函数组件useRef</span>
<span class="line">    <span class="token keyword">const</span> currentDom <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="高阶用法" tabindex="-1"><a class="header-anchor" href="#高阶用法"><span>高阶用法</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token number">1.</span> forwardRef 转发Ref</span>
<span class="line"><span class="token operator">&gt;</span> 解决ref不能跨层级捕获和传递的问题</span>
<span class="line"><span class="token operator">&gt;</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token operator">&gt;</span>     <span class="token keyword">return</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line"><span class="token operator">&gt;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token number">2.</span> 合并转发ref</span>
<span class="line"><span class="token operator">&gt;</span> 传递合并之后的自定义的ref</span>
<span class="line"></span>
<span class="line"><span class="token number">3.</span> 高阶组件转发</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ref实现组件通信</p><ol><li>类组件ref</li><li>函数组件 forwardRef + useImperativeHandle</li></ol>`,76)])])}const r=s(l,[["render",o]]),u=JSON.parse('{"path":"/react.html","title":"React 进阶实践","lang":"zh-CN","frontmatter":{},"git":{"contributors":[{"name":"安晓凯","username":"","email":"xiaokai.an@17zuoye.com","commits":1}],"changelog":[{"hash":"9d63165ab1d659f6f6902440afd29500cb7f8ae7","time":1769689566000,"email":"xiaokai.an@17zuoye.com","author":"安晓凯","message":"feat:增加React"}]},"filePathRelative":"react.md"}');export{r as comp,u as data};
